# Sorting
- Sorting is nothing but a way to sort the array in increasing or decreasing order.
- It is very useful to store the data in an organized way.
- Makes it easier to apply algorithms on data to retrieve useful data like min value in array, max value and so on.
- There are many ways to do the sorting.
- These include selection-sort, bubble-sort, insertion-sort.
- We will be learning how to sort in ascending order and then same concept can be applied to sort in decreasing order.
## **<u>*Selection Sort*</u>
- It is the most simpler way of sorting the array.
- Logic is simple , find the smallest elements and put them in ascending order in array.
### Time complexity and Space complexity
It has a time complexity of O(n<sup>2</sup>) and space complexity of O(1) where "n" is the size of array.
### Theory
- We simply find the smallest element in the array and then put it on the zeroth index.
- Then , find the next large element and put on oneth index.
- Keep on doing it until array is sorted.
### Approach
1. Intialize the array/vector and get user input inside our main function as follows:-
```C++
    int x;
    cout << "enter no of elements"<<endl;            
    cin >> x;
    vector<int> arr;
    int a;
    cout << "enter elements"<<endl;
    for(int i = 0 ; i<x ; i++)
    {
        cin >> a;
        arr.push_back(a);
    }
```
2. Then intialize a for loop to iterate through n-1 elements in the array and declare a mini variable to find the element with minimum value. Intialize with value of arr[i] and index = i.
```C++
    for(int i = 0 ; i<arr.size(); i++)
    {
        int mini = arr[i] , index = i;
    }
```
3. Since we will be comparing every "i" th element  with the rest of the elements from this position , declare a for loop inside this for loop to iterate from i+1 to "<arr.size()".
```C++
    for(int i = 0 ; i<arr.size(); i++)
    {
        int mini = arr[i] , index = i;
        for(int j = i+1 ; j<arr.size() ; j++)
        {

        }
    }
```
4. Comapre with every "j" th element and find the smallest one and swap it with current element at the index.
```C++
for(int i = 0 ; i<arr.size()-1; i++) //iterating through each element in array
    {
        int mini = arr[i] , index = i;
        for(int j = i+1; j<arr.size() ; j++) //iterating from i+1 till last element
        {
            if(mini>arr[j]) //find minimum element
            {
                index=j;
                mini=arr[j];
            }
        }
        swap(arr[index],arr[i]); //swapping current element and minimum element
    }
```
5. Print the array
### Problem
- No doubt the algorithm will sort our array. However , it can be very time consuming.
- Suppose we are given an array which is already sorted. But the selection sort will not be able to identify that the array is already sorted and will iterate through whole array n times so it will waste alot of time.
- Moreover, it will give TLE(time limit exceeded) error for large arrays.

## **<u>*Bubble sort*</u>
- A bit complex than the selection sort, this algorithm provides us the solution to sort the partially sorted large arrays in optimal time limit.
- The approach is simple , compare the element with the next element and swap if the element is larger than the later element.
- Repeat this until the array is sorted.
### Time complexity and space complexity
It has a time complexity of O(n<sup>2</sup>) with a best case senario of O(n) and a space complexity of O(1).
### Theory
- The approach is simple , compare the element with the next element and swap if the element is larger than the later element.
- Each time we traverse the complete array and do the swapping , the largest element is placed at the last index and subsequent elements start to arrange themselves.
- So , each time , no of iterations are reduced by 1.
- At end , the array is sorted.
### Approach
1. Get the user input in main function and store it in an array or vector.
```C++
    int x;
    cout << "enter no of elements"<<endl;
    cin >> x;
    vector<int> arr;
    int a;
    cout << "enter elements"<<endl;
    for(int i = 0 ; i<x ; i++)
    {
        cin >> a;
        arr.push_back(a);
    }
```
2. Intialize a for loop to iterate from i=1 to i<n-1.
```C++
for(int i = 1 ; i<arr.size()-1 ; i++)
{

}
```
3. Inside this for loop , intialize another for loop to iterate from j = 0 to j <arr.size()-i.
```C++
for(int i = 1 ; i<arr.size()-1 ; i++)
{
    for(int j = 0 ; j<arr.size()-i ; j++)
    {

    }
}
```
4. If arr[j]>arr[j+1] , then do the swapping
```C++
for(int i = 1 ; i<arr.size()-1 ; i++)
{
    int s=1;
    for(int j = 0 ; j<arr.size()-i ; j++)
    {
        if(arr[j]>arr[j+1])
        {
            swap(arr[j],arr[j+1]);
            s=0;
        }
    }
}
```
5. For optimization , if no sort is performed then array is already sorted. Therefore , break ouy of the loop.
```C++
for(int i = 1 ; i<arr.size()-1 ; i++)
{
    int s=1;
    for(int j = 0 ; j<arr.size()-i ; j++)
    {
        if(arr[j]>arr[j+1])
        {
            swap(arr[j],arr[j+1]);
            s=0;
        }
    }
    if(s==1)
    {
        break;
    }
}
```
6. Print the array.
### Problem 
- It is not efficient for sorting large datasets.
- Less efficient than Insertion sort.
